<!DOCTYPE html>
<html lang="ch-ZN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Tetris</title>
    <link href="./style/global.css" rel="stylesheet" type="text/css" />
    <link href="./style/index.css" rel="stylesheet" type="text/css" />
  </head>

  <body style="margin: 0px; overflow: hidden; font-family: Monospace">
    <!-- three.js library -->
    <script src="vendor/three.js/build/three.min.js"></script>
    <script src="vendor/three.js/examples/js/libs/stats.min.js"></script>
    <!-- ar.js -->
    <script src="ar-threex.js"></script>
    <script>
      THREEx.ArToolkitContext.baseURL = "../";
    </script>
    <script src="js/vconsole.min.js"></script>
    <script src="js/Tetris.js"></script>
    <script type="text/javascript">
      var vConsole = new VConsole();
    </script>

    <!-- 模型加载 -->
    <script src="vendor/three.js/GLTFLoader.js"></script>

    <div class="operation-container flex-row">
      <div class="left-container flex-col">
        <div class="start-container flex-row">
          <div class="btn-container flex-col">
            <button class="common-btn start-btn" onclick="startGame()"></button>
            <span>Start</span>
          </div>
          <div class="btn-container flex-col">
            <button
              class="common-btn start-btn"
              onclick="restartGame()"
            ></button>
            <span>Reset</span>
          </div>
        </div>
      </div>
      <div class="right-container">
        <div class="direction-item flex-row">
          <div class="btn-container flex-col rotation">
            <button
              class="common-btn start-btn"
              onclick="rotateCell()"
            ></button>
            <span>Rotation</span>
          </div>
        </div>
        <div class="direction-item flex-row">
          <div class="btn-container flex-col left">
            <button
              class="common-btn start-btn"
              onclick="moveLeftAndRight(0)"
            ></button>
            <span>Left</span>
          </div>
          <div class="btn-container flex-col right">
            <button
              class="common-btn start-btn"
              onclick="moveLeftAndRight(1)"
            ></button>
            <span>Right</span>
          </div>
        </div>
        <div class="direction-item flex-row">
          <div class="btn-container flex-col bottom">
            <button class="common-btn start-btn" onclick="moveDown()"></button>
            <span>Bottom</span>
          </div>
        </div>
      </div>
    </div>
    <script>
      //////////////////////////////////////////////////////////////////////////////////
      //		Init
      //////////////////////////////////////////////////////////////////////////////////

      let width = window.innerWidth,
        height = window.innerHeight;
      console.log("window.innerWidth", width, height);
      // init renderer
      var renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setClearColor(new THREE.Color("lightgrey"), 0);
      // renderer.setPixelRatio( 1/2 );
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.position = "absolute";
      renderer.domElement.style.top = "0";
      renderer.domElement.style.left = "0";
      document.body.appendChild(renderer.domElement);

      // array of functions for the rendering loop
      var onRenderFcts = [];
      var onRenderFctsmy = {};

      var arToolkitContext, artoolkitMarker, markerRoot;

      // init scene and camera
      var scene = new THREE.Scene();

      //////////////////////////////////////////////////////////////////////////////////
      //		Initialize a basic camera
      //////////////////////////////////////////////////////////////////////////////////

      // Create a camera
      var camera = new THREE.Camera();
      scene.add(camera);

      markerRoot = new THREE.Group();
      scene.add(markerRoot);

      ////////////////////////////////////////////////////////////////////////////////
      //          handle arToolkitSource
      ////////////////////////////////////////////////////////////////////////////////

      var arToolkitSource = new THREEx.ArToolkitSource({
        // to read from the webcam
        sourceType: "webcam",

        // to read from an image
        // sourceType : 'image',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/images/img.jpg',

        // to read from a video
        // sourceType : 'video',
        // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
      });

      arToolkitSource.init(function onReady() {
        initARContext();
        onResize();
      });

      // handle resize
      window.addEventListener("resize", function () {
        onResize();
      });

      function onResize() {
        arToolkitSource.onResizeElement();
        arToolkitSource.copyElementSizeTo(renderer.domElement);
        if (window.arToolkitContext.arController !== null) {
          arToolkitSource.copyElementSizeTo(
            window.arToolkitContext.arController.canvas
          );
        }
      }
      ////////////////////////////////////////////////////////////////////////////////
      //          initialize arToolkitContext
      ////////////////////////////////////////////////////////////////////////////////

      // create atToolkitContext
      function initARContext() {
        console.log("initARContext()");

        arToolkitContext = new THREEx.ArToolkitContext({
          cameraParametersUrl:
            "https://ued.united-imaging.com/doc_server/doc_server/resource/src/343c761a5174cf7f427e30ba75ceb63f.dat",
          detectionMode: "mono",
          maxDetectionRate: 30,
          canvasWidth: 80 * 3,
          canvasHeight: 60 * 3,
        });
        // initialize it
        arToolkitContext.init(function onCompleted() {
          // copy projection matrix to camera
          camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
          arToolkitContext.arController.orientation = getSourceOrientation();
          arToolkitContext.arController.options.orientation =
            getSourceOrientation();

          console.log("arToolkitContext", arToolkitContext);
          window.arToolkitContext = arToolkitContext;
        });
        artoolkitMarker = new THREEx.ArMarkerControls(
          arToolkitContext,
          markerRoot,
          {
            type: "pattern",
            patternUrl:
              "https://ued.united-imaging.com//doc_server//doc_server//arlib//pattern//123//pattern.patt",
            // patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji'
          }
        );
      }

      function getSourceOrientation() {
        if (!arToolkitSource) {
          return null;
        }

        console.log(
          "actual source dimensions",
          arToolkitSource.domElement.videoWidth,
          arToolkitSource.domElement.videoHeight
        );

        if (
          arToolkitSource.domElement.videoWidth >
          arToolkitSource.domElement.videoHeight
        ) {
          console.log("source orientation", "landscape");
          return "landscape";
        } else {
          console.log("source orientation", "portrait");
          return "portrait";
        }
      }

      // update artoolkit on every frame
      onRenderFcts.push(function () {
        if (!arToolkitContext || !arToolkitSource || !arToolkitSource.ready) {
          return;
        }

        arToolkitContext.update(arToolkitSource.domElement);
      });

      ////////////////////////////////////////////////////////////////////////////////
      //          Create a ArMarkerControls
      ////////////////////////////////////////////////////////////////////////////////

      var markerRoot = new THREE.Group();
      scene.add(markerRoot);

      // // build a smoothedControls
      var smoothedRoot = new THREE.Group();
      scene.add(smoothedRoot);
      var smoothedControls = new THREEx.ArSmoothedControls(smoothedRoot, {
        lerpPosition: 0.4,
        lerpQuaternion: 0.3,
        lerpScale: 1,
      });
      onRenderFcts.push(function (delta) {
        smoothedControls.update(markerRoot);
      });
      // //////////////////////////////////////////////////////////////////////////////////
      // //		add an object in the scene
      // //////////////////////////////////////////////////////////////////////////////////

      var arWorldRoot = smoothedRoot;

      // 设置一个方格长宽为20
      let cubeWidth = 0.1;
      // 横向10格，纵向20格, 间隙为4
      let lineWidthSeg = 9,
        lineHeightSeg = 10,
        seg = 0.02;
      // 计算外框线长与宽
      let lineWidth = cubeWidth * lineWidthSeg + seg * (lineWidthSeg + 1);
      let lineHeight = cubeWidth * lineHeightSeg + seg * (lineHeightSeg + 1);

      // 存储方块的矩阵
      let matrix = [],
        nextMatrix = [];
      // 定时器
      let timer;

      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();

      class Cube {
        constructor(type, position) {
          // 方块类型
          this.type = type;
          // 记录方块当前的位置信息
          this.position = position;
        }
      }

      let haveStart = false;
      let currentCube = null;
      let nextCube = null;
      let score = 0;
      let speed = 800;
      let scoreLabel;
      let canUpdate = false;
      const imgUrl = "./image/cell.png";

      //深度拷贝
      function copyArr(m) {
        return JSON.parse(JSON.stringify(m));
      }

      // 光
      var ambient = new THREE.AmbientLight(0xffffff);
      scene.add(ambient);

      var directctionalLight = new THREE.DirectionalLight(0xffffff);
      directctionalLight.position.set(1, 1, 1).normalize();
      scene.add(directctionalLight);

      //////////////////////////////////////////////////////////////////////////////////
      //		render the whole thing on the page
      //////////////////////////////////////////////////////////////////////////////////
      var stats = new Stats();
      document.body.appendChild(stats.dom);
      // render the scene
      onRenderFcts.push(function () {
        renderer.render(scene, camera);
        stats.update();
      });

      // run the rendering loop
      var lastTimeMsec = null;
      requestAnimationFrame(function animate(nowMsec) {
        // keep looping
        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
        var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec = nowMsec;
        // call each update function
        onRenderFcts.forEach(function (onRenderFct) {
          onRenderFct(deltaMsec / 1000, nowMsec / 1000);
        });
        Object.values(onRenderFctsmy).forEach(function (onRenderFct) {
          onRenderFct(deltaMsec / 1000, nowMsec / 1000);
        });
      });

      initCubes();
      generateCube();
      generateLines();

      function generateLines(param) {
        let rect = new THREE.Group();
        let lineMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
        });
        // let TopAnBottomGeometry = new THREE.BufferGeometry();
        // TopAnBottomGeometry.setFromPoints([
        //   new THREE.Vector3(1, 0, 1),
        //   new THREE.Vector3(1, 0, 2),
        // ]);
        // let topLine = new THREE.Line(TopAnBottomGeometry, lineMaterial);
        // // scene.add(topLine);
        // arWorldRoot.add(topLine);

        let TopAnBottomGeometry = new THREE.BufferGeometry();
        let LeftAndRightGeometry = new THREE.BufferGeometry();

        TopAnBottomGeometry.setFromPoints([
          new THREE.Vector3(
            -lineWidth / 2 - cubeWidth / 2 - seg,
            0,
            lineHeight / 2 + seg
          ),
          new THREE.Vector3(
            lineWidth / 2 + cubeWidth / 2 + seg,
            0,
            lineHeight / 2 + seg
          ),
        ]);

        let top = new THREE.Line(TopAnBottomGeometry, lineMaterial);
        let bottom = top.clone(true);
        bottom.position.z = -lineHeight;

        LeftAndRightGeometry.setFromPoints([
          new THREE.Vector3(
            -lineWidth / 2 - cubeWidth / 2 - seg,
            0,
            lineHeight / 2 + seg
          ),
          new THREE.Vector3(
            -lineWidth / 2 - cubeWidth / 2 - seg,
            0,
            -lineHeight / 2
          ),
        ]);
        let left = new THREE.Line(LeftAndRightGeometry, lineMaterial);
        let right = left.clone(true);
        right.position.x = lineWidth / 2 + cubeWidth / 2 + seg;

        rect.add(top, left, right);
        scene.add(rect);
        arWorldRoot.add(rect);
      }

      //生成下一个方块
      function generateCube() {
        // 判断是否输了
        if (isLose()) {
          score = 0;
          // scoreLabel.material.map = new THREE.CanvasTexture(
          //   generateSprite("score:" + score, "red")
          // );
          return restartGame();
        }
        let types = [
          new Cube(1, [
            [0, 3],
            [0, 4],
            [0, 5],
            [0, 6],
          ]),
          new Cube(2, [
            [0, 3],
            [1, 3],
            [1, 4],
            [1, 5],
          ]),
          new Cube(3, [
            [0, 5],
            [1, 3],
            [1, 4],
            [1, 5],
          ]),
          new Cube(4, [
            [0, 4],
            [0, 5],
            [1, 4],
            [1, 5],
          ]),
          new Cube(5, [
            [0, 5],
            [0, 6],
            [1, 4],
            [1, 5],
          ]),
          new Cube(6, [
            [0, 5],
            [1, 4],
            [1, 5],
            [1, 6],
          ]),
          new Cube(7, [
            [0, 3],
            [0, 4],
            [1, 4],
            [1, 5],
          ]),
        ];

        // 随机生成七种形状之一
        if (nextCube == null) {
          currentCube = types[Math.floor(Math.random() * 7)];
        } else {
          currentCube = nextCube;
        }
        nextCube = types[Math.floor(Math.random() * 7)];

        let pos = currentCube.position;
        let nextPos = nextCube.position;
        for (let i = 0; i < pos.length; i++) {
          matrix[pos[i][0]][pos[i][1]].cube.visible = true;
        }

        //隐藏之前的下一个方格
        for (let i = 0; i < nextMatrix.length; i++) {
          for (let j = 0; j < nextMatrix[i].length; j++) {
            nextMatrix[i][j].visible = false;
          }
        }

        // //显示下一个cube
        // for (let i = 0; i < nextPos.length; i++) {
        //   nextMatrix[nextPos[i][0]][nextPos[i][1] - 3].visible = true;
        // }
      }

      function initCubes() {
        matrix = [];
        let matrixObject = new THREE.Object3D();
        let cube = new THREE.BoxGeometry(cubeWidth, cubeWidth / 50, cubeWidth);
        let map = new THREE.TextureLoader().load(imgUrl);
        map.wrapS = map.mapT = THREE.RepeatWrapping;
        let material = new THREE.MeshLambertMaterial({
          map,
          side: THREE.DoubleSide,
        });
        let mesh = new THREE.Mesh(cube, material);
        let m = 0,
          n = 0;
        // 初始化所有方块设置为隐藏
        for (
          let j = lineHeight / 2 - cubeWidth / 2 - seg;
          j > -lineHeight / 2;
          j -= cubeWidth + seg, m++, n = 0
        ) {
          matrix[m] = [];
          for (
            let i = -lineWidth / 2;
            i < lineWidth / 2;
            i += cubeWidth + seg, n++
          ) {
            // console.log("lineWidth", lineWidth, "i", i, "j", j);
            mesh = mesh.clone(true);
            mesh.receiveShadow = true;
            mesh.position.set(i, 0, -j);
            mesh.visible = false;
            matrix[m][n] = {
              cube: mesh,
            };
            matrixObject.add(mesh);
          }
        }
        scene.add(matrixObject);
        arWorldRoot.add(matrixObject);
      }

      // 开始游戏
      function startGame() {
        console.log("startGame");
        if (!haveStart) {
          timer = setInterval(() => {
            moveDown();
          }, speed);
          haveStart = true;
        }
      }

      // 重新开始游戏
      function restartGame() {
        if (haveStart) {
          score = 0;
          clearInterval(timer);
          matrix.forEach((m) => {
            m.forEach((n) => {
              n.cube.visible = false;
            });
          });
          generateCube();
          haveStart = false;
        }
      }

      // 旋转
      function rotateCell() {
        console.log("rotateCell");

        let pos = currentCube.position;
        let copy = copyArr(currentCube.position);
        let type = currentCube.type;

        // 某点(ab)绕点（mn）逆时针90度 得点（m+n-b,n-m+a)
        let cx = Math.round(
          (copy[0][0] + copy[1][0] + copy[2][0] + copy[3][0]) / 4
        );
        let cy = Math.round(
          (copy[0][1] + copy[1][1] + copy[2][1] + copy[3][1]) / 4
        );
        //旋转的主要算法. 可以这样分解来理解。
        //先假设围绕源点旋转。然后再加上中心点的坐标。
        for (let i = 0; i < 4; i++) {
          copy[i][0] = cx + cy - pos[i][1];
          copy[i][1] = cy - cx + pos[i][0];
        }

        //对横向长条以及两个S型进行精度补偿
        if (type == 1 || type == 5 || type == 7) {
          if (copy[0][0] == copy[1][0]) {
            for (let i = 0; i < 4; i++) {
              copy[i][0] -= 1;
            }
          }
        }

        let canRotate = true;
        let minus = minusMatrix(copy, pos);
        for (let i = 0; i < minus.length; i++) {
          if (
            minus[i][0] < 0 ||
            minus[i][1] < 0 ||
            minus[i][0] > 19 ||
            minus[i][1] > 9
          ) {
            canRotate = false;
            break;
          }
          if (matrix[minus[i][0]][minus[i][1]].cube.visible == true) {
            canRotate = false;
            break;
          }
        }
        if (canRotate) {
          canUpdate = true;
          updateMatrixView(copy);
          currentCube.position = copy;
        }
      }

      // 向下移动
      function moveDown() {
        console.log("moveDown", currentCube);
        let pos = currentCube.position;
        let x, y;
        let newPos = [];
        let canMove = true;
        for (let i = 0; i < pos.length; i++) {
          (x = pos[i][0]), (y = pos[i][1]);
          if (x + 1 <= lineHeightSeg - 1) {
            newPos.push([x + 1, y]);
          } else {
            break;
          }
        }
        if (newPos.length == pos.length) {
          //计算出变更前后两个矩阵的差集
          let minus = minusMatrix(newPos, pos);
          //判断变更的部分能否移动
          for (let i = 0; i < minus.length; i++) {
            if (matrix[minus[i][0]][minus[i][1]].cube.visible != false) {
              canMove = false;
              break;
            }
          }
          if (canMove) {
            canUpdate = true;
            updateMatrixView(newPos);
            currentCube.position = newPos;
          } else {
            // 如果发生碰撞了,先消除
            clearCubes();
            generateCube();
          }
        } else {
          // 如果到最底层了，重新生成图案
          clearCubes();
          generateCube();
        }
      }

      //判断是否输了
      function isLose() {
        let num = 0;
        for (let i = 3; i <= 6; i++) {
          if (matrix[0][i].cube.visible == true) {
            num++;
          }
        }
        return num >= 3;
      }

      // 左右移动
      function moveLeftAndRight(type) {
        let pos = currentCube.position;
        let x, y;
        let newPos = [];
        let canMove = true;
        let step = type == 0 ? -1 : 1;
        for (let i = 0; i < pos.length; i++) {
          (x = pos[i][0]), (y = pos[i][1]);
          if (y + step >= 0 && y + step <= lineWidthSeg - 1) {
            newPos.push([x, y + step]);
          } else {
            break;
          }
        }
        if (newPos.length == pos.length) {
          //计算出变更前后两个矩阵的差集
          let minus = minusMatrix(newPos, pos);
          //判断变更的部分能否移动
          for (let i = 0; i < minus.length; i++) {
            if (matrix[minus[i][0]][minus[i][1]].cube.visible != false) {
              canMove = false;
              break;
            }
          }
          if (canMove) {
            canUpdate = true;
            updateMatrixView(newPos);
            currentCube.position = newPos;
          }
        }
      }

      //更新视图矩阵
      function updateMatrixView(newPos) {
        if (canUpdate) {
          let pos;
          //将之前的隐藏
          for (let i = 0; i < currentCube.position.length; i++) {
            pos = currentCube.position[i];
            matrix[pos[0]][pos[1]].cube.visible = false;
          }
          //显示新的
          for (let i = 0; i < newPos.length; i++) {
            matrix[newPos[i][0]][newPos[i][1]].cube.visible = true;
          }
        }
      }

      //计算两个二维数组差集,用于判断变更后的部分能否移动
      function minusMatrix(m1, m2) {
        let arr = [];
        let flag = true;
        for (let i = 0; i < m1.length; i++) {
          flag = true;
          for (let j = 0; j < m2.length; j++) {
            if (m1[i][0] == m2[j][0] && m1[i][1] == m2[j][1]) {
              flag = false;
              break;
            }
          }
          if (flag) {
            arr.push([m1[i][0], m1[i][1]]);
          }
        }
        return arr;
      }

      // 清除某一行全部点亮的
      function clearCubes() {
        canUpdate = false;
        let clear = false,
          lineNumber = [];
        for (let i = 0; i <= lineHeightSeg - 1; i++) {
          for (let j = 0; j <= lineWidthSeg - 1; j++) {
            // 判断某一行是否全部点亮
            if (matrix[i][j].cube.visible == true) {
              clear = true;
            } else {
              clear = false;
              break;
            }
          }
          if (clear) {
            lineNumber.push(i);
          }
        }
        if (lineNumber.length > 0) {
          //加分
          score += lineNumber.length * lineWidthSeg;
          // scoreLabel.material.map = new THREE.CanvasTexture(
          //   generateSprite("score:" + score, "red")
          // );

          //消除完整
          for (let i = lineNumber.length - 1; i >= 0; i--) {
            for (let j = 0; j <= lineWidthSeg - 1; j++) {
              matrix[lineNumber[i]][j].cube.visible = false;
            }
          }

          //将上面的移动下来
          for (let i = 0; i < lineNumber.length; i++) {
            for (let j = lineNumber[i]; j >= 1; j--) {
              for (let k = 0; k <= lineWidthSeg - 1; k++) {
                if (matrix[j - 1][k].cube.visible == true) {
                  matrix[j - 1][k].cube.visible = false;
                  matrix[j][k].cube.visible = true;
                }
              }
            }
          }
        }
      }
    </script>
  </body>
</html>
